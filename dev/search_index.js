var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"DocTestSetup = quote using Quasar end\nCurrentModule = Quasar","category":"page"},{"location":"#Quasar","page":"Home","title":"Quasar","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Quasar.jl, the Qu(antum) as(sembly) (lex/pars)er, is a package for lexing and parsing the OpenQASM quantum assembly IR.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Quasar works in a two-step fashion: first, it uses a tokenizer to generate an abstract syntax tree (AST) representing the quantum program, which is a nested structure of QasmExpressions. Then, it walks (visits) the AST to evaluate all loops, conditionals, gate calls, and variable declarations.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Quasar has support for:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Basic builtin OpenQASM 3 gates gphase and U\nCustom gate definitions\nfor and while loops\nif, else, and switch conditional statements\nBuiltin OpenQASM3 functions\nFunction definitions and calls\nCasting classical types\nTiming statements barrier and delay\nPragmas (see below)","category":"page"},{"location":"","page":"Home","title":"Home","text":"What is not yet supported:","category":"page"},{"location":"","page":"Home","title":"Home","text":"angle types\nAnnotations\nOpenPulse","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you need any of these features, feel free to open an issue requesting support for them!","category":"page"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"For more extensive examples, see the tests in test/. Here, we can parse and visit a simple OpenQASM 3.0 program to generate a Bell circuit:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> qasm = \"\"\"OPENQASM 3.0;\\ngate h a { U(π/2, 0, π) a; gphase(-π/4);};\\ngate x a { U(π, 0, π) a; gphase(-π/2);};\\ngate cx a, b { ctrl @ x a, b; };\\ndef bell(qubit q0, qubit q1) {\\n    h q0;\\n    cx q0, q1;\\n}\\nqubit[2] q;\\nbell(q[0], q[1]);\\nbit[2] b = \"00\";\\nb[0] = measure q[0];\\nb[1] = measure q[1];\\n\"\"\";\n\njulia> parsed = Quasar.parse_qasm(qasm);\n\njulia> visitor = Quasar.QasmProgramVisitor();\n\njulia> visitor(parsed);","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can supply inputs to your program by creating the QasmProgramVisitor with a Dict{String, Any} containing the names of the input variables as the keys and their values as the Dict's values. This allows you to re-use the same AST multiple times for different inputs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Once the visitor has walked the AST, its instructions field contains CircuitInstruction NamedTuples you can use to construct your own circuit instruction types. These tuples have fields:","category":"page"},{"location":"","page":"Home","title":"Home","text":"type::String - the name of the instruction, e.g. \"measure\" or \"cx\"\narguments - any arguments the instruction accepts, such as an angle for an rx gate or a Period for a duration \ntargets::Vector{Int} - the qubits targeted by this instruction. This should include any control qubits. \ncontrols::Vector{Pair{Int,Int}} - any controls (including negctrl) applied to the instruction. The first item in the pair is the qubit, the second is the value controlled upon, so that 2=>0 represents a negctrl on qubit 2.\nexponent::Float64 - the pow modifier applied to the instruction, if any","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can use a package such as StructTypes.jl to build your circuits and programs from these named tuples.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In the above example, the h, x, and cx were defined in terms of the built-in gates U and gphase. In many cases, you may have an implementation of these gates that is simpler or more efficient. In that case, you can supply your own gate definition file using the include instruction, or provide a function to generate a dictionary of builtin gates to Quasar.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Quasar\n\nfunction my_builtin_generator()\n    ...\nend\n\nQuasar.builtin_gates[] = my_builtin_generator","category":"page"},{"location":"","page":"Home","title":"Home","text":"A generator function is used here in order to allow visitors to overwrite builtin functions in certain scopes without corrupting the reference definition. If you're writing a package which uses Quasar, the Quasar.builtin_gates[] = my_builtin_generator should be placed in your main module's __init__ function. ","category":"page"},{"location":"#Working-with-pragmas","page":"Home","title":"Working with pragmas","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"OpenQASM pragmas allow specific platforms to provide custom instructions. Quasar.jl provides a bare parse_pragma function you can override and extend to support parsing your pragma constructs. This will teach Quasar.jl how to incorporate your pragma instructions into the AST. You will also need to write a visit_pragma function for the AST walking step. You may want to use pragmas to support custom circuit operations (like noise channels) or results. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Your parse_pragma should take four arguments:","category":"page"},{"location":"","page":"Home","title":"Home","text":"tokens – some vector of tokens generated by the tokenizer which represents the pragma line, with the leading #pragma removed\nstack – the current stack of QasmExpressions, used for error reporting\nstart – the location in the QASM source string of the start of the #pragma line, used for error reporting\nqasm – the QASM source string, used for error reporting","category":"page"},{"location":"","page":"Home","title":"Home","text":"Your visit_pragma should take two arguments:","category":"page"},{"location":"","page":"Home","title":"Home","text":"visitor – any subtype of AbstractVisitor, e.g. a QasmProgramVisitor, QasmForLoopVisitor, etc.\nexpr – the QasmExpression containing your full pragma invocation, generated by the above parse_pragma function","category":"page"}]
}
